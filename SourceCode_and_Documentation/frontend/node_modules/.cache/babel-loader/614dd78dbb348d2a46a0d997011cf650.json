{"ast":null,"code":"module.exports = {\n  compareTwoStrings: compareTwoStrings,\n  findBestMatch: findBestMatch\n};\n\nfunction compareTwoStrings(first, second) {\n  first = first.replace(/\\s+/g, '');\n  second = second.replace(/\\s+/g, '');\n  if (first === second) return 1; // identical or empty\n\n  if (first.length < 2 || second.length < 2) return 0; // if either is a 0-letter or 1-letter string\n\n  let firstBigrams = new Map();\n\n  for (let i = 0; i < first.length - 1; i++) {\n    const bigram = first.substring(i, i + 2);\n    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;\n    firstBigrams.set(bigram, count);\n  }\n\n  ;\n  let intersectionSize = 0;\n\n  for (let i = 0; i < second.length - 1; i++) {\n    const bigram = second.substring(i, i + 2);\n    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) : 0;\n\n    if (count > 0) {\n      firstBigrams.set(bigram, count - 1);\n      intersectionSize++;\n    }\n  }\n\n  return 2.0 * intersectionSize / (first.length + second.length - 2);\n}\n\nfunction findBestMatch(mainString, targetStrings) {\n  if (!areArgsValid(mainString, targetStrings)) throw new Error('Bad arguments: First argument should be a string, second should be an array of strings');\n  const ratings = [];\n  let bestMatchIndex = 0;\n\n  for (let i = 0; i < targetStrings.length; i++) {\n    const currentTargetString = targetStrings[i];\n    const currentRating = compareTwoStrings(mainString, currentTargetString);\n    ratings.push({\n      target: currentTargetString,\n      rating: currentRating\n    });\n\n    if (currentRating > ratings[bestMatchIndex].rating) {\n      bestMatchIndex = i;\n    }\n  }\n\n  const bestMatch = ratings[bestMatchIndex];\n  return {\n    ratings: ratings,\n    bestMatch: bestMatch,\n    bestMatchIndex: bestMatchIndex\n  };\n}\n\nfunction areArgsValid(mainString, targetStrings) {\n  if (typeof mainString !== 'string') return false;\n  if (!Array.isArray(targetStrings)) return false;\n  if (!targetStrings.length) return false;\n  if (targetStrings.find(function (s) {\n    return typeof s !== 'string';\n  })) return false;\n  return true;\n}","map":{"version":3,"sources":["/Users/nickramsay/Documents/Projects/seng2021-project/SourceCode_and_Documentation/frontend/node_modules/string-similarity/src/index.js"],"names":["module","exports","compareTwoStrings","findBestMatch","first","second","replace","length","firstBigrams","Map","i","bigram","substring","count","has","get","set","intersectionSize","mainString","targetStrings","areArgsValid","Error","ratings","bestMatchIndex","currentTargetString","currentRating","push","target","rating","bestMatch","Array","isArray","find","s"],"mappings":"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","sourcesContent":["module.exports = {\n\tcompareTwoStrings:compareTwoStrings,\n\tfindBestMatch:findBestMatch\n};\n\nfunction compareTwoStrings(first, second) {\n\tfirst = first.replace(/\\s+/g, '')\n\tsecond = second.replace(/\\s+/g, '')\n\n\tif (first === second) return 1; // identical or empty\n\tif (first.length < 2 || second.length < 2) return 0; // if either is a 0-letter or 1-letter string\n\n\tlet firstBigrams = new Map();\n\tfor (let i = 0; i < first.length - 1; i++) {\n\t\tconst bigram = first.substring(i, i + 2);\n\t\tconst count = firstBigrams.has(bigram)\n\t\t\t? firstBigrams.get(bigram) + 1\n\t\t\t: 1;\n\n\t\tfirstBigrams.set(bigram, count);\n\t};\n\n\tlet intersectionSize = 0;\n\tfor (let i = 0; i < second.length - 1; i++) {\n\t\tconst bigram = second.substring(i, i + 2);\n\t\tconst count = firstBigrams.has(bigram)\n\t\t\t? firstBigrams.get(bigram)\n\t\t\t: 0;\n\n\t\tif (count > 0) {\n\t\t\tfirstBigrams.set(bigram, count - 1);\n\t\t\tintersectionSize++;\n\t\t}\n\t}\n\n\treturn (2.0 * intersectionSize) / (first.length + second.length - 2);\n}\n\nfunction findBestMatch(mainString, targetStrings) {\n\tif (!areArgsValid(mainString, targetStrings)) throw new Error('Bad arguments: First argument should be a string, second should be an array of strings');\n\t\n\tconst ratings = [];\n\tlet bestMatchIndex = 0;\n\n\tfor (let i = 0; i < targetStrings.length; i++) {\n\t\tconst currentTargetString = targetStrings[i];\n\t\tconst currentRating = compareTwoStrings(mainString, currentTargetString)\n\t\tratings.push({target: currentTargetString, rating: currentRating})\n\t\tif (currentRating > ratings[bestMatchIndex].rating) {\n\t\t\tbestMatchIndex = i\n\t\t}\n\t}\n\t\n\t\n\tconst bestMatch = ratings[bestMatchIndex]\n\t\n\treturn { ratings: ratings, bestMatch: bestMatch, bestMatchIndex: bestMatchIndex };\n}\n\nfunction areArgsValid(mainString, targetStrings) {\n\tif (typeof mainString !== 'string') return false;\n\tif (!Array.isArray(targetStrings)) return false;\n\tif (!targetStrings.length) return false;\n\tif (targetStrings.find( function (s) { return typeof s !== 'string'})) return false;\n\treturn true;\n}\n"]},"metadata":{},"sourceType":"script"}